## Vector 

vector 컨테이너는 대표적인 시퀀스 컨테이너로, 배열과 비슷하여 사용이 쉬우며 자주 사용된다.
vector는 임의 접근 반복자(Random Access Iterator)를 지원하는 배열 기반 컨테이너이다.
vector의 가장 큰 특징 중 하나는 원소가 ** 하나의 메모리 블록에 연속하게 저장 ** 된다는 것이다. <br>
그렇다 보니 원소가 추가되거나, 삽입될 때 메모리 재할당이 발생할 수 있고 상당한 비용을 지불하게 된다. 그래서 메모리 할당 크기를 알 수 있게 capacity() 함수를 제공하며, 한번에 메모리를 할당할 수 있는 reserve() 함수도 제공된다.

` 메모리에서 V를 vector에 의해 생성된 메모리라고 하자, [VVVV]가 할당되어 있는데, 다른 메모리 O가 들어와서 [VVVVOOO]의 메모리 구조가 되었음. 그런데, vector에 추가적으로 할당되어서 V가 늘어나게 되면 연속적인 vector의 메모리 구조에 문제가 생기겠지? 뒤에 OOO가 있으니.<br>그래서 VVVV를 다 지우고, 다른 공간에 VVVV에 이어서 VVVVVVV 만들겠지. 이렇기 때문에, ** 재 할당시 상당한 비용 ** 이 든다는 것! `


### 생성자

`vector v` : v는 빈 컨테이너이다.
`vector v(n)` : v는 기본적으로 초기화된 n개의 원소를 갖는다.	// 0으로 초기화됨.
`vector v(n,x)` : v는 x값으로 초기화된 n개의 원소를 갖는다.
`vector v(v2)` : v는 v2 컨테이너의 복사본이다. (복사 생성자 호출)

### 멤버함수

`v.assign(n,x)` : v에 x값으로 n개의 원소를 할당한다.
`v.at(i)` : v의 i번째 원소를 참조한다.
`v.back()` : v의 마지막 원소를 참조한다.
`p=v.begin()` : p는 v의 첫 원소를 가리키는 반복자.
`x=v.capacity()` : x는 v에 할당된 공간의 크기.
`v.clear()` : v의 모든 원소를 제거한다.
`v.empty()` : v가 비었는지 조사한다.
`p=v.end()` : p는 v의 끝을 표식하는 반복자.
`p=v.erase(p)` : p가 가리키는 원소를 제거한다.
`q=v.erase(b,e)반복자 구간 [b,e)의 모든 원소를 제거한다. q는 다음 원소.
`v.front()` : v의 첫 번째 원소를 참조한다.
`q=v.insert(p,x)` : p에서 가리키는 위치에 x값을 삽입한다. q는 삽입한 원소를 가리키는 반복자.
`v.insert(p,n,x)` : p가 가리키는 위치에 n개의 x값을 삽입한다.
`v.insert(p,b,e)` : p가 가리키는 위치에 반복자 구간 [b,e)의 원소를 삽입한다.
`x=v.max_size()` : x는 v가 담을 수 있는 최대 원소의 개수(메모리의 크기).
`v.pop_back()` : v의 마지막 원소를 제거한다.
`v.push_back()` : v의 끝에 x를 추가한다.
`p.reserve(n)` : n개의 원소를 저장할 공간을 예약한다.
`v.resize(n)` : v의 크기를 n으로 변경하고, 확장되는 공간의 값을 기본값으로 초기화한다.
`v.resize(n,x)` : v의 크기를 n으로 변경하고, 확장되는 공간의 값을 x값으로 초기화한다.
`v.size()` : v의 원소 갯수.
`v.swap(v2)` : v와 v2를 swap한다.
